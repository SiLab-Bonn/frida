
// Include Files
`include "constants.h"			
`include "discipline.h"
`define NUM_OF_BINS 100

module TRAN_Dynamic_RiseFallTime(NodeToMeasure);
input NodeToMeasure;
electrical NodeToMeasure;

// Baseline & Topline parameters
parameter real StableFrom = 0.0 from [0:inf);		// Start calculating the baseline and topline in the interval [StableFrom, StableTo]
parameter real StableTo = 0.0 from [0:inf);			// Start calculating the baseline and topline in the interval [StableFrom, StableTo].  If StableTo is equal to 0, then it means the end of the simulation.
parameter real SamplePeriod = 0.0 from [0:inf);		// This is the sampling period for histogram.  If this is zero, then sampling interval is divided by NumOfSamples for SamplePeriod.
parameter integer NumOfSamples = 2000 from (0:inf);	// Number of samples to use to calculate the SamplePeriod. SamplePeriod = (StableTo - StabelFrom)/NumOfSamples

// Measurement Parameters
parameter real LowerThreshold = 20.0 from [0:100];	// Lower threshold for the rise/fall time calculation in percent.
parameter real UpperThreshold = 80.0 from [0:100];	// Upper threshold for the rise/fall time calculation in percent.
parameter integer Number = 0 from [0:inf);	// Use the nth rising/falling edge in the calculation. 0 means all edges in the interval.
parameter real MeasureFrom = 0.0 from [0:inf);	// Unused
parameter real MeasureTo = 0.0 from [0:inf);		// Unused

// Test Parameters
parameter string TestName = "";
parameter integer ID = 1;						// ID used to identify the simulation run.  This is useful for .alter and sweeps.
parameter string OutputFilename = "";		// Base Output File name and path without extension. It will create two files OutputFilename_Rise.out and OutputFilename_Fall.out

parameter integer Debug = 0 from [0:1];

// Variables
string sTempFileName = "TEMP";
integer nDataFileID = 0;
integer nRiseOutFileID = 0;
integer nFallOutFileID = 0;
string sRiseFileName = "Rise";
string sFallFileName = "Fall";

real dFinalTime = 0;

// Baseline & Topline variables
real dMax = 0.0;
real dMin = 0.0;
integer nNumberOfBins = `NUM_OF_BINS;
integer nBins[0:`NUM_OF_BINS-1];
integer nNumRead = 0;
real dBinSize = 0.0;
integer nNumberOfSamples = 2000;
real dSampleSize = 0.0;
real dPrevX = 0.0;
real dCurrentX = 0.0;
real dPrevY = 0.0;
real dCurrentY = 0.0;
real dNextSamplePoint = 0.0;
real dY = 0.0;
integer i = 0;
integer nMaxIndex = 0;
integer nMaxCount = 0;
real dBaseLine = 0.0;
real dTopLine = 0.0;

// Measurement variables
real dMidLine = 0.0;
real dLT = 0.0;
real dUT = 0.0;
real dLowerRisingTime = 0.0;
real dUpperRisingTime = 0.0;
real dLowerFallingTime = 0.0;
real dUpperFallingTime = 0.0;

analog function real Interpolate;
input dX0, dX1, dY0, dY1, dXvalue;
real dX0, dX1, dY0, dY1, dXvalue;
real dTemp;
 begin
 	Interpolate = dY0 + ((dXvalue-dX0)*dY1 - (dXvalue-dX0)*dY0)/(dX1-dX0);
 end
endfunction

analog
begin
	@(initial_step("tran"))
	 begin
		$sformat(sTempFileName,"%m_Data.dat");
		nDataFileID = $fopen(sTempFileName, "w");
		if (nDataFileID == 0)
		 begin
			$strobe("WARNING: (%d) Cannot open temporary data file \"%s\"", nDataFileID, sTempFileName);
		 end

		// Make sure you can write to the risetime output file.
		$sformat(sRiseFileName,"%s_Rise.out", OutputFilename);
		nRiseOutFileID = $fopen(sRiseFileName, "w");
		if (nRiseOutFileID == 0)
		 begin
			$strobe("WARNING: (%d) Cannot open risetime output file file \"%s\"", nRiseOutFileID, sRiseFileName);
		 end
		else
		 $fclose(nRiseOutFileID);
		nRiseOutFileID = 0;

		// Make sure you can write to the falltime output file.
		$sformat(sFallFileName,"%s_Fall.out", OutputFilename);
		nFallOutFileID = $fopen(sFallFileName, "w");
		if (nFallOutFileID == 0)
		 begin
			$strobe("WARNING: (%d) Cannot open risetime output file file \"%s\"", nFallOutFileID, sFallFileName);
		 end
		else
		 $fclose(nFallOutFileID);
		nFallOutFileID = 0;

	 	dMax = V(NodeToMeasure);
	 	dMin = V(NodeToMeasure);
	 end

	// Only calculate it during the interval specified.
	if (($abstime >= StableFrom) && (($abstime <= StableTo) || (StableTo <= 0.0)))
	 begin
		// Save the signal for later processing
		if (nDataFileID != 0)
			$fstrobe(nDataFileID, "%g %g", $abstime, V(NodeToMeasure));

		// Calculate the Max and Min.
		if (V(NodeToMeasure) > dMax)
			dMax = V(NodeToMeasure);
		if (V(NodeToMeasure) < dMin)
			dMin = V(NodeToMeasure);
		dFinalTime = $abstime;
	 end

	@(final_step("tran"))
	 begin
	 	// Close the data file
	 	if (nDataFileID != 0)
	 	 begin
	 		$fclose(nDataFileID);
	 		nDataFileID = 0;
	 	 end

	 	// Calculate the TopLine and BaseLine
	 	begin
	 		dBinSize = abs(dMax-dMin)/nNumberOfBins;
		 	if ( SamplePeriod <= 0 )
		 	 begin
		 	 	if ( NumOfSamples <= 0 )
		 			dSampleSize = abs(dFinalTime - StableFrom)/nNumberOfSamples;
		 		else
					dSampleSize = abs(dFinalTime - StableFrom)/NumOfSamples;
			 end
			else
				dSampleSize = SamplePeriod;

		 	if ( Debug )
	 		 begin
		 		$strobe("Max = %g", dMax);
		 		$strobe("Min = %g", dMin);
		 		$strobe("Bin Size = %g", dBinSize);
		 		$strobe("Sample Size = %g", dSampleSize);
		 	 end

			nDataFileID = $fopen(sTempFileName, "r");
			if (nDataFileID != 0)
			 begin
			 	// Initialize the bin counts
			 	for (i = 0; i < `NUM_OF_BINS; i = i +1)
			 	 begin
			 	 	nBins[i] = 0;
			 	 end

			 	// Read the data file and sample the signal based on the sampling period.
			 	nNumRead = 2;
			 	dNextSamplePoint = StableFrom;
			 	dPrevX = -1.0;
			 	dPrevY = 0.0;
				while (nNumRead == 2)
				 begin
			 		nNumRead = $fscanf(nDataFileID, "%f %f", dCurrentX, dCurrentY);
					if (nNumRead == 2)
					 begin
					 	// Don't work on the first data point because we need 2 data points for interpolation.
					 	if ( dPrevX >= 0 )
					 	 begin
							if ((dCurrentX >= dNextSamplePoint) && (dPrevX <= dNextSamplePoint))
					 		 begin
					 		 	// Found a sample point.  Interpolate the Y value.
					 			dY = Interpolate(dPrevX, dCurrentX, dPrevY, dCurrentY, dNextSamplePoint);

					 			// Calculate which bin the Y value is in and increment that bin.
					 			i = (dY-dMin)/dBinSize;
					 			if ( i > 99 )
					 				i = 99;
					 			nBins[i] = nBins[i] + 1;
		 						if ( Debug )
	 		 					 begin
									$strobe("Found One = %r, %r, %r, %r", dPrevX, dPrevY, dCurrentX, dCurrentY);
									$strobe("dY = %r (%d)", dY, i);
								 end
								 // Calculate the next sample point.
					 			dNextSamplePoint = dNextSamplePoint + dSampleSize;
					 	 	 end
					 	 end
					 end
			 		dPrevX = dCurrentX;
			 		dPrevY = dCurrentY;
			 	 end

			 	// Calculate the bin with the maximum count in the first half of the bins.
			 	// This will be the baseline.
			 	nMaxIndex = 0;
				nMaxCount = nBins[nMaxIndex];
			 	for (i = nMaxIndex+1; i < `NUM_OF_BINS / 2; i = i +1)
			 	 begin
					if ( nBins[i] > nMaxCount )
					 begin
					 	nMaxCount = nBins[i];
					 	nMaxIndex = i;
					 end
			 	 end
			 	dBaseLine = dMin + (nMaxIndex*dBinSize);

			 	// Calculate the bin with the maximum count in the second half of the bins.
			 	// This will be the topline.
			 	nMaxIndex = `NUM_OF_BINS / 2;
				nMaxCount = nBins[nMaxIndex];
			 	for (i = nMaxIndex+1; i < `NUM_OF_BINS; i = i +1)
			 	 begin
					if ( nBins[i] > nMaxCount )
					 begin
					 	nMaxCount = nBins[i];
					 	nMaxIndex = i;
					 end
			 	 end
			 	dTopLine = dMin + (nMaxIndex*dBinSize);
				if ( Debug )
	 		 	 begin
				 	for (i = 0; i < `NUM_OF_BINS; i = i +1)
				 	 begin
				 	 	$strobe("Bin %d = %d", i, nBins[i]);
				 	 end
			 		$strobe("Baseline = %r", dBaseLine);
			 		$strobe("Topline = %r", dTopLine);
			 	 end
			 	// Close the data file
		 		if (nDataFileID != 0)
		 	 	 begin
		 			$fclose(nDataFileID);
		 			nDataFileID = 0;
		 	 	 end
		 	 end
		 	else
		 	 begin
				$strobe("WARNING: (%d) Cannot open temporary data file \"%s\"", nDataFileID, sTempFileName);
		 	 end
		end

		// Calculate the risetime
		begin
			dMidLine = (dTopLine+dBaseLine)/2.0;
			nDataFileID = $fopen(sTempFileName, "r");
			if (nDataFileID != 0)
			 begin
				nRiseOutFileID = $fopen(sRiseFileName, "w");
	 			nFallOutFileID = $fopen(sFallFileName, "w");
				if ((nRiseOutFileID != 0) && (nFallOutFileID != 0))
			 	 begin
			 	 	$fstrobe(nRiseOutFileID, "ID, Temp, time, RiseTime");
			 	 	$fstrobe(nFallOutFileID, "ID, Temp, time, FallTime");
				 	dLT = dBaseLine + (dTopLine-dBaseLine)*LowerThreshold/100;
					dUT = dBaseLine + (dTopLine-dBaseLine)*UpperThreshold/100;
		 			if ( Debug )
	 		 		 begin					
						$strobe("Baseline = %r", dBaseLine);
						$strobe("Topline = %r", dTopLine);
						$strobe("Midline = %r", dMidLine);
						$strobe("Lower Threshold = %r", dLT);
						$strobe("Upper Threshold = %r", dUT);
					 end
				 	dLowerRisingTime = 0.0;
					dUpperRisingTime = 0.0;
				 	dLowerFallingTime = 0.0;
					dUpperFallingTime = 0.0;
				 	// Read the data file
				 	nNumRead = 2;
				 	dPrevX = -1.0;
				 	dPrevY = 0.0;
				 	i = 1;
					while (nNumRead == 2)
					 begin
				 		nNumRead = $fscanf(nDataFileID, "%f %f", dCurrentX, dCurrentY);
						if (nNumRead == 2)
						 begin
							// Don't work on the first data point because we need 2 data points to check for rising/falling.
						 	if ( dPrevX > 0 )
						 	 begin
						 	 	// Check for rising edge
						 	 	if ((dPrevY < dLT) && (dCurrentY > dLT))
						 	 	 begin
						 	 		dLowerRisingTime =  Interpolate(dPrevY, dCurrentY, dPrevX, dCurrentX, dLT);
		 							if ( Debug )
	 		 						 begin						 	 		
						 	 			$strobe("Lower Rising Time = %r", dLowerRisingTime);
						 	 		 end
						 	 	 end
						 	 	if ((dPrevY < dUT) && (dCurrentY > dUT))
						 	 	 begin
						 	 		dUpperRisingTime =  Interpolate(dPrevY, dCurrentY, dPrevX, dCurrentX, dUT);
		 							if ( Debug )
	 		 						 begin						 	 		
						 	 			$strobe("Upper Rising Time = %r", dUpperRisingTime);
						 	 			$strobe("Rise Time = %r", dUpperRisingTime-dLowerRisingTime);
						 	 		 end
						 	 		if ((Number == 0) || (i == Number))
						 	 			$fstrobe(nRiseOutFileID, "%d, %r, %r, %r", ID, $temperature, dLowerRisingTime, (dUpperRisingTime-dLowerRisingTime));
						 	 	 end
						 	 	// Check for falling edge
						 	 	if ((dPrevY > dLT) && (dCurrentY < dLT))
						 	 	 begin
						 	 		dLowerFallingTime =  Interpolate(dPrevY, dCurrentY, dPrevX, dCurrentX, dLT);
		 							if ( Debug )
	 		 						 begin						 	 								 	 		
										$strobe("Lower Falling Time = %r", dLowerFallingTime);
										$strobe("Fall Time = %r", dLowerFallingTime-dUpperFallingTime);
									 end
						 	 		if ((Number == 0) || (i == Number))
						 	 			$fstrobe(nFallOutFileID, "%d, %r, %r, %r", ID, $temperature, dUpperFallingTime, (dLowerFallingTime-dUpperFallingTime));
						 	 	 end
						 	 	if ((dPrevY > dUT) && (dCurrentY < dUT))
						 	 	 begin
						 	 		dUpperFallingTime =  Interpolate(dPrevY, dCurrentY, dPrevX, dCurrentX, dUT);
		 							if ( Debug )
	 		 						 begin						 	 								 	 		
						 	 			$strobe("Upper Falling Time = %r", dUpperFallingTime);
						 	 		 end
						 	 	 end
						 	 end
						 end
				 		dPrevX = dCurrentX;
				 		dPrevY = dCurrentY;
					 end

					$fclose(nRiseOutFileID);
	 				nRiseOutFileID = 0;
	 				$fclose(nFallOutFileID);
	 				nFallOutFileID = 0;
				 end
	 			$fclose(nDataFileID);
	 			nDataFileID = 0;
	 	 	 end
		end
	 end
end
// Module contents

endmodule // TRAN_Measure_Dynamic_Risetime
