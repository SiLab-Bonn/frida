

It includes DRC and LVS rules, SPICE models, technology files, verification and extraction files, execution scripts, symbol library and parametric cells (PCells)

OpenAccess file format comes with APIs for C++, C#, Perl, Python, Ruby and Tcl.

[Blog describing some issues](https://semiwiki.com/x-subscriber/silvaco/5601-custom-ic-design-flow-with-openaccess/)

Interoperable PDK (iPDK) came from TSMC starting in 2007, and by 2009 the first 65nm iPDK was ready. The iPDK Alliance called IPL controls the iPDK specification and members include: Altera (Intel), Ciranova, Mentor Graphics, Pulsic, SpringSoft, Synospys and TSM with Xilinx and STMicroelectronics as advisors. With iPDK the foundry and partners spend less time on PDK development. The Interoperable PDK Libraries Alliance (IPL), working with TSMC, standardized on using Ciranova’s PyCell approach (based on Python rather than SKILL) and created the iPDK which is supported by all the layout editors (even Virtuoso, at least unofficially).

As with much in the EDA industry, there will be multiple standards so OpenPDK is yet another approach, this time from Si2.org, using an XML structured file and translators for main vendor tools. Each supplier creates their own parser to create the standardized exchange format. An OPDK can also create an iPDK. There is a second portable PDK standard anyway called OpenPDK, being done under the umbrella of Si2, although the work just started last year and hasn’t yet delivered actual PDKs. Supported by Global foundaries. Si2 is perceived by other EDA vendors as being too close to Cadence (they also nurture OpenAccess and CPF, which both started off internally inside Cadence)


All of this IC design reuse sounds really promising and liberating, however there are some issue for you to aware of. There can be subtle differences between Cadence PDK (using Skill), iPDK (Tcl), custom PDK (Tcl, Python, Perl). 

tsmcn65 ivpcell
What is a ivpcell?



[From Si2 website](https://si2.org/os-downloads/):

OpenPDK Coalition

The OpenPDK (Process Design Kit) Coalition was founded in 2010 to define a set of open standards allowing an OpenPDK to be created (once) and translated into specific EDA vendor tools and foundry formats. This allows for maximum portability across foundries and agnosticism among EDA tools. The Si2 OpenPDK standard enables greater efficiency in PDK development, verification, and delivery, providing equal support to foundries, EDA tool vendors, IP providers, and end-users.

Specifications

    OpenPDK Open Process Specification (OPS): This specification enables foundries to study and create electronic versions of DRM and to gather early feedback on completeness.
    OPS 1.2 supports the creation of a techfile/oaTech.db for foundry-specific layer information. This includes grids, connectivity, display information, and version information. This release also integrates the Device Parameters (previously called Design Parameters) and Tool Interface standards into OPS.
    OpenPDK PCell Standard (PCell v1.0 is compatible with OPS 1.2)
    OpenPDK Design Parameter and Callback Specification V1.0
    OpenPDK Schematic Symbol Standard V1.0


The term "callback" is used for a number of different situations, but in general it's a means of having a function that gets called when some kind of event occurs. In this case it's called when the simulation finishes. In some cases the callback is a complete SKILL expression which is just evaluated using evalstring, but in others you provide the name of the function to call (or in an increasing number of cases, you can also provide the function object which is beneficial when using SKILL++). In this case you're doing just that - providing the name of the function to call.

# Opensource EDA in Europe
The US isn't dominating contributions to open source EDA. OpenROad -> OpenLane is US based but..
Actually, the many of the important and essential tools in open source EDA are fundamentally being developed in Europe (e.g. klayout (Munich), yosys (Vienna), nextpnr (Vienna/Heidelberg), ngspice (Duisburg)).


# Parasitic extraction

Parasitic extraction yeilds something called a DSPF file, or Detailed Standard Parasitic Format
It's a spice netlists generated by StarRC, QRC, Calibre, etc which is directly simulatable with design devices and parasitic devices
It's not a standardized format, unlike [SPEF](https://en.wikipedia.org/wiki/Standard_Parasitic_Exchange_Format) which is IEEE standardized


# Notes from Jun 25, 2024:

This idea of having 'procedural generators', with parameterizable and verified layout+models is (in a limited way) essentially what a PCell is. Now, there isn't a direct hook to run a simulations and plotting, but as long as you can overtime develop the model with your own manually triggered simulations, in the end you have a

PyCells support process portability, by allowing for 'correct-by-construction' functions which take a technology description as input, and for example place two transistors 'as-close-as-possible'.

PyCells don't allow themselves for parameterized batch simulation, but the standard testbenching tools from Cadence e.g. will let you sweep any parameter exposed by the Pcell


 

## Alternative layout strategies:

Layouts can be generated via a host of different methods. Here is short summary:

- **Skill PCell**, written in Virtuoso embedded LISP dialect Skill. When imported, it becomes a OA PCell which is viewable in the Cadence library viewer.
- **PyCell**, developer by Ciranova and acquired by Synopsys, these are available via the IPL iPDK alliances and allow creation of OA PCells. They appear as a line item in a Cadence, Synopsys, and Siemens library viewer, but don't compile down to binary OA Pcells. Instead they rely on Python at runtime to call the C++ implementation of OA. Can be developed in PyCell studio.
- **Skill Interface** Some tools work by sending commands over Virtuoso's Skill interface. The two prime examples are SkillBridge and BAG2.Laygo2 also supports this. They have no resting date format, and rely on Skill/Virtuoso at runtime.
- **Dump to GDS** Many open source tools rely on writing raw GDS. They include Laygo2, Substrate2, Layout21, 
- **
tcl pcell
bag3 raw oa output
klayout python/ruby pcell
how does synopsys really do pcells natively?
magic vlsi

What's important is to have the a device model tuned to device dimensions, and to be able to keep these in sync.

From [this thesis, page 57:](https://archiv.ub.uni-heidelberg.de/volltextserver/30559/)

> Besides the PyCell code, it is necessary to provide a technology file to the cngenlib command to generate the OpenAccess database library for Virtuoso. This technology file is also needed to display the layers within PyCell Studio and has to be in the "Santana" format

> The parent directory to the directory with the PyCell code has to be added to the $PYTHONPATH environment variable. If this is not done correctly, Virtuoso cannot find the PyCell.

> The $OA_PLUGIN_PATH environment variable contains the paths to Virtuoso plugins(.plg). It should be set correctly by sourcing the PyCell Studio script.

> The gcc version of the PyCell Studio and the system running Virtuoso should match to properly use the PyCells.

From [LayoutEditor docs](https://layouteditor.org/layout/basics/installation) I found:

> Synopsys provides packages created with different compilers. Packages generated by a new compiler may cause problems if not used by your system. So for RHEL package until version 7, and Ubuntu package until version 16.04, please use PyCell installations for gcc48x. Starting with RHEL8 and Ubuntu 18.04, packages generated with gcc62 will work. The PyCell installer may see several error messages on Ubuntu-based systems, nevertheless mostly it is installed correctly. If it is not done, try to set the compiler version manual: export OA_COMPILER="gcc62" before starting the PyCell installer.


From [LayoutEditor Wiki:](http://www.layouteditor.net/wiki/iPDK)

- OpenAccess can store layout data, schematics, symbols, netlists and any other application specific data. These information are stored into many files in a directory tree.
- IPL iPDKs are based on OpenAcess and glued together with Python and TCL
- Technology files include .drf, CdsTech Virtuoso ASCII file, OA libs.def or OA cds.lib
- Some iPKDs (e.g. many PDKs from TSMC) come with an own version of PyCell and run only with this version correctly. If that is the case for your PDK, please use the PyCell version shipped by your foundery. In this case:
- As PyCell isn't in the default location `/opt/synopsys`, one must use `$CNI_ROOT` and probably also `$LD_LIBRARY_PATH`
-  `lib.defs` is the main configuration file for OpenAccess
- In iPDKs, TCL is typically used for the callback functions, which for example are used to calculate a capacitor's new value after changing the width or length.
- An other known problem is that some founderies use an extended Tcl API and implement these extended calls for some tools. So the 'iPDK' becomes incompatible to other tools. The extensions needs to implement for the LayoutEditor was well to use the iPDK. As an example for this problem the TowerJazz iPDKs use an API call iPDK_getParamList which is not part of the original iPDK specification. To use this iPDK with the LayoutEditor an additional Tcl file had to be included into the callback folder
- Layer definitions can come from either `tech.db` file, `Santana.tech` and or from the `layer.map` file
