# -*- coding: utf-8 -*-
"""DFF generation with laygo2 for SKY130.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dToEQe7500TUNOPN2aPTJGRgcbbNsqhj

# **D flip-flop (DFF) layout generation using laygo2**

spdx-license-identifier: bsd-3-clause

Draw a D flip-flop with subcells for the SKY130 technology using [laygo2](https://laygo2.github.io) and export it to a png image.

## Install conda and dependencies
"""

import os

CONDA_PREFIX = os.environ.get('CONDA_PREFIX', None)
if not CONDA_PREFIX:
  !python -m pip install condacolab
  import condacolab
  condacolab.install()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile environment.yml
# channels:
#   - litex-hub
#   - conda-forge
# dependencies:
#   - open_pdks.sky130a
#   - magic
#   #- ngspice-lib
#   - gdstk
#   - pip
#   - pip:
#     - laygo2
#     - gdspy
#     - pyyaml
#     - cairosvg
#   #  - pyspice

!mamba env update -n base -f environment.yml
# Load test technology (laygo2_tech_test).
#!git clone https://github.com/niftylab/laygo2.git
#!ln -s ./laygo2/laygo2_tech_quick_start .

import os

CONDA_PREFIX = os.environ.get('CONDA_PREFIX', None)
if not CONDA_PREFIX:
  import condacolab
  CONDA_PREFIX = condacolab.PREFIX

"""## Install the laygo2 workspace for the sky130 technology"""

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/niftylab/laygo2_workspace_sky130.git
# %cd laygo2_workspace_sky130
!git submodule init
!git submodule update
!mkdir ./magic_layout/logic_generated

"""## Import packages, set parameters, and load templates/grids"""

import numpy as np
import pprint
import laygo2
import laygo2.interface
import laygo2_tech as tech

# Parameter definitions #############
# Templates
tpmos_name = 'pmos_sky'
tnmos_name = 'nmos_sky'
# Grids
pg_name = 'placement_basic'
r12_name = 'routing_12_cmos'
r23_name = 'routing_23_cmos'
# Design hierarchy
libname = 'logic_generated'
# cellname in for loop
ref_dir_template = './'
ref_dir_MAG_exported = './'
# End of parameter definitions ######

# 1. Load templates and grids.
print("Load templates")
templates = tech.load_templates()
tpmos, tnmos = templates[tpmos_name], templates[tnmos_name]
print(templates[tpmos_name], templates[tnmos_name], sep="\n")

print("Load grids")
grids = tech.load_grids(templates=templates)
pg, r12, r23 = grids[pg_name], grids[r12_name], grids[r23_name]
print(grids[pg_name], grids[r12_name], grids[r23_name], sep="\n")

"""## Generate subcell inverters"""

# Inverter Variables
celltype = 'inv'
nf_list = [2, 4]

# Generation start ##################
lib = laygo2.object.database.Library(name=libname)

for nf in nf_list:
   cellname = celltype+'_'+str(nf)+'x'
   print('--------------------')
   print('Now Creating '+cellname)

   # 2. Create a design hierarchy
   dsn = laygo2.object.database.Design(name=cellname, libname=libname)
   lib.append(dsn)

   # 3. Create instances.
   print("Create instances")
   in0 = tnmos.generate(name='MN0', params={'nf': nf, 'tie': 'S'})
   ip0 = tpmos.generate(name='MP0', transform='MX', params={'nf': nf,'tie': 'S'})

   # 4. Place instances.
   dsn.place(grid=pg, inst=in0, mn=[0,0])
   dsn.place(grid=pg, inst=ip0, mn=pg.mn.top_left(in0) + pg.mn.height_vec(ip0))

   # 5. Create and place wires.
   print("Create wires")
   # IN
   _mn = [r23.mn(in0.pins['G'])[0], r23.mn(ip0.pins['G'])[0]]
   _track = [r23.mn(in0.pins['G'])[0,0]-1, None]
   rin0 = dsn.route_via_track(grid=r23, mn=_mn, track=_track)

   # OUT
   _mn = [r23.mn(in0.pins['D'])[1], r23.mn(ip0.pins['D'])[1]]
   vout0, rout0, vout1 = dsn.route(grid=r23, mn=_mn, via_tag=[True, True])

   # VSS
   rvss0 = dsn.route(grid=r12, mn=[r12.mn(in0.pins['RAIL'])[0], r12.mn(in0.pins['RAIL'])[1]])

   # VDD
   rvdd0 = dsn.route(grid=r12, mn=[r12.mn(ip0.pins['RAIL'])[0], r12.mn(ip0.pins['RAIL'])[1]])

   # 6. Create pins.
   pin0 = dsn.pin(name='I', grid=r23, mn=r23.mn.bbox(rin0[2]))
   pout0 = dsn.pin(name='O', grid=r23, mn=r23.mn.bbox(rout0))
   pvss0 = dsn.pin(name='VSS', grid=r12, mn=r12.mn.bbox(rvss0))
   pvdd0 = dsn.pin(name='VDD', grid=r12, mn=r12.mn.bbox(rvdd0))

   # 7. Export to physical database.
   print("Export design")
   print("")

   # Magic tcl export.
   tcl_script = laygo2.interface.magic.export(lib, filename=ref_dir_MAG_exported +libname+'_'+cellname+'.tcl', cellname=None, libpath=ref_dir_template+'magic_layout', scale=1, reset_library=False, tech_library='sky130A')
   # 8. Export to a template database file.
   nat_temp = dsn.export_to_template()
   laygo2.interface.yaml.export_template(nat_temp, filename=ref_dir_template+libname+'_templates.yaml', mode='append')

"""## Generate subcell tri-state inverters"""

# Tri-state inverter variables
celltype = 'tinv'
nf_list = [2,4]

for nf in nf_list:
   cellname = celltype+'_'+str(nf)+'x'
   print('--------------------')
   print('Now Creating '+cellname)

   # 2. Create a design hierarchy
   dsn = laygo2.object.database.Design(name=cellname, libname=libname)
   lib.append(dsn)

   # 3. Create istances.
   print("Create instances")
   in0 = tnmos.generate(name='MN0', params={'nf': nf, 'tie': 'S'})
   ip0 = tpmos.generate(name='MP0', transform='MX', params={'nf': nf, 'tie': 'S'})
   in1 = tnmos.generate(name='MN1', params={'nf': nf, 'trackswap': True})
   ip1 = tpmos.generate(name='MP1', transform='MX', params={'nf': nf,'trackswap': True})

   # 4. Place instances.
   dsn.place(grid=pg, inst=in0, mn=[0,0])
   dsn.place(grid=pg, inst=ip0, mn=pg.mn.top_left(in0) + pg.mn.height_vec(ip0))
   dsn.place(grid=pg, inst=in1, mn=pg.mn.bottom_right(in0))
   dsn.place(grid=pg, inst=ip1, mn=pg.mn.top_right(ip0))

   # 5. Create and place wires.
   print("Create wires")
   # IN
   _mn = [r23.mn(in0.pins['G'])[0], r23.mn(ip0.pins['G'])[0]]
   v0, rin0, v1 = dsn.route(grid=r23, mn=_mn, via_tag=[True, True])

   # OUT
   _mn = [r23.mn(in1.pins['D'])[1], r23.mn(ip1.pins['D'])[1]]
   vout0, rout0, vout1 = dsn.route(grid=r23, mn=_mn, via_tag=[True, True])

   # EN
   _mn = [r23.mn(in1.pins['G'])[1]+[1,0], r23.mn(ip1.pins['G'])[1]+[1,0]]
   ven0, ren0 = dsn.route(grid=r23, mn=_mn, via_tag=[True, False])
   _mn = [r23.mn(in1.pins['G'])[1], r23.mn(in1.pins['G'])[1]+[1,0]]
   renint = dsn.route(grid=r23, mn=_mn)

   # ENB
   _mn = [r23.mn(in1.pins['G'])[1]+[-1,0], r23.mn(ip1.pins['G'])[1]+[-1,0]]
   renb0, venb0 = dsn.route(grid=r23, mn=_mn, via_tag=[False, True])

   # Internal
   _mn = [r23.mn(ip0.pins['D'])[0], r23.mn(ip1.pins['S'])[0]]
   rintp0 = dsn.route(grid=r23, mn=_mn)
   _mn = [r23.mn(in0.pins['D'])[0], r23.mn(in1.pins['S'])[0]]
   rintn0 = dsn.route(grid=r23, mn=_mn)

   # VSS
   rvss0 = dsn.route(grid=r12, mn=[r12.mn(in0.pins['RAIL'])[0], r12.mn(in1.pins['RAIL'])[1]])

   # VDD
   rvdd0 = dsn.route(grid=r12, mn=[r12.mn(ip0.pins['RAIL'])[0], r12.mn(ip1.pins['RAIL'])[1]])

   # 6. Create pins.
   pin0 = dsn.pin(name='I', grid=r23, mn=r23.mn.bbox(rin0))
   pen0 = dsn.pin(name='EN', grid=r23, mn=r23.mn.bbox(ren0))
   penb0 = dsn.pin(name='ENB', grid=r23, mn=r23.mn.bbox(renb0))
   pout0 = dsn.pin(name='O', grid=r23, mn=r23.mn.bbox(rout0))
   pvss0 = dsn.pin(name='VSS', grid=r12, mn=r12.mn.bbox(rvss0))
   pvdd0 = dsn.pin(name='VDD', grid=r12, mn=r12.mn.bbox(rvdd0))

   # 7. Export to physical database.
   print("Export design")
   # Magic tcl export.
   laygo2.interface.magic.export(lib, filename=ref_dir_MAG_exported +libname+'_'+cellname+'.tcl', cellname=None, libpath=ref_dir_template+'magic_layout', scale=1, reset_library=False, tech_library='sky130A')

   # 8. Export to a template database file.
   nat_temp = dsn.export_to_template()
   laygo2.interface.yaml.export_template(nat_temp, filename=ref_dir_template+libname+'_templates.yaml', mode='append')

"""## Generate a feedback tri-state inverter subcell"""

# Variables
cell_type = 'tinv_small'
cellname = cell_type+'_'+str(nf)+'x'
nf = 1

# 2. Create a design hierarchy
lib = laygo2.object.database.Library(name=libname)
dsn = laygo2.object.database.Design(name=cellname, libname=libname)
lib.append(dsn)

# 3. Create istances.
print("Create instances")
nstack = templates['nmos13_fast_center_2stack'].generate(name='nstack')
nbndl = templates['nmos13_fast_boundary'].generate(name='nbndl')
nbndr = templates['nmos13_fast_boundary'].generate(name='nbndr')
nspace0 = templates['nmos13_fast_space'].generate(name='nspace0')
nspace1 = templates['nmos13_fast_space'].generate(name='nspace1')
pstack = templates['pmos13_fast_center_2stack'].generate(name='pstack', transform='MX')
pbndl = templates['pmos13_fast_boundary'].generate(name='pbndl', transform='MX')
pbndr = templates['pmos13_fast_boundary'].generate(name='pbndr', transform='MX')
pspace0 = templates['pmos13_fast_space'].generate(name='pspace0', transform='MX')
pspace1 = templates['pmos13_fast_space'].generate(name='pspace1', transform='MX')

# 4. Place instances.
dsn.place(grid=pg, inst=nbndl, mn=[0,0])
dsn.place(grid=pg, inst=nstack, mn=pg.mn.bottom_right(nbndl))
dsn.place(grid=pg, inst=nbndr, mn=pg.mn.bottom_right(nstack))
dsn.place(grid=pg, inst=nspace0, mn=pg.mn.bottom_right(nbndr))
dsn.place(grid=pg, inst=nspace1, mn=pg.mn.bottom_right(nspace0))
dsn.place(grid=pg, inst=pbndl, mn=pg.mn.top_left(nbndl)+pg.mn.height_vec(pbndl))
dsn.place(grid=pg, inst=pstack, mn=pg.mn.top_right(pbndl))
dsn.place(grid=pg, inst=pbndr, mn=pg.mn.top_right(pstack))
dsn.place(grid=pg, inst=pspace0, mn=pg.mn.top_right(pbndr))
dsn.place(grid=pg, inst=pspace1, mn=pg.mn.top_right(pspace0))

# 5. Create and place wires.
print("Create wires")

# IN
_mn = [r12.mn(nstack.pins['G0'])[0], r12.mn(pstack.pins['G0'])[0]]
rin0 = dsn.route(grid=r23, mn=_mn)
_mn = [r12.mn(nstack.pins['G0'])[0], r12.mn(pstack.pins['G0'])[0]]
dsn.route(grid=r12, mn=_mn)
_mn = [np.mean(r23.mn.bbox(rin0), axis=0, dtype=np.int), np.mean(r23.mn.bbox(rin0), axis=0, dtype=np.int)+[2,0]]
dsn.route(grid=r23, mn=_mn, via_tag=[True, False])
dsn.via(grid=r12, mn=np.mean(r23.mn.bbox(rin0), axis=0, dtype=np.int))

# OUT
_mn = [r23.mn(nstack.pins['D0'])[0], r23.mn(pstack.pins['D0'])[1]]
vout0, rout0, vout1 = dsn.route(grid=r23, mn=_mn, via_tag=[True, True])
vint0 = dsn.via(grid=r12, mn=r23.mn(nstack.pins['D0'])[0])
vint1 = dsn.via(grid=r12, mn=r23.mn(pstack.pins['D0'])[1])

# EN
_mn = [r23.mn(nstack.pins['G1'])[0], r23.mn(nstack.pins['G1'])[0]+[1,0]]
ren0, ven0 = dsn.route(grid=r23, mn=_mn, via_tag=[False, True])
ven1 = dsn.via(grid=r12, mn=r12.mn(nstack.pins['G1'])[0])
_mn = [r23.mn(nstack.pins['G1'])[0]+[1,0], r23.mn(pstack.pins['G1'])[0]+[1,0]]
ren1 = dsn.route(grid=r23, mn=_mn)

# ENB
_mn = [r23.mn(pstack.pins['G1'])[0], r23.mn(pstack.pins['G1'])[0]+[-1,0]]
renb0, venb0 = dsn.route(grid=r23, mn=_mn, via_tag=[False, True])
venb1 = dsn.via(grid=r12, mn=r12.mn(pstack.pins['G1'])[0])
_mn = [r23.mn(pstack.pins['G1'])[0]+[-1,0], r23.mn(nstack.pins['G1'])[0]+[-1,0]]
renb1 = dsn.route(grid=r23, mn=_mn)

# VSS
# M2 Rect
_mn = [r12.mn.bottom_left(nbndl), r12.mn.bottom_right(nspace1)]
rvss0 = dsn.route(grid=r12, mn=_mn)

# tie
_mn = [r12.mn(nstack.pins['S0'])[0], r12.mn(nstack.pins['S0'])[0]+[0,-1]]
rvss1, _ = dsn.route(grid=r12, mn=_mn, via_tag=[False, True])

# VDD
# M2 Rect
_mn = [r12.mn.top_left(pbndl), r12.mn.top_right(pspace1)]
rvdd0 = dsn.route(grid=r12, mn=_mn)

# tie
_mn = [r12.mn(pstack.pins['S0'])[1], r12.mn(rvdd0)[0]+[1,0]]
rvdd1 = dsn.route(grid=r12, mn=_mn, via_tag=[False, True])

# 6. Create pins.
pin0 = dsn.pin(name='I', grid=r23, mn=r23.mn.bbox(rin0))
pout0 = dsn.pin(name='O', grid=r23, mn=r23.mn.bbox(rout0))
pen0 = dsn.pin(name='EN', grid=r23, mn=r23.mn.bbox(ren1))
penb0 = dsn.pin(name='ENB', grid=r23, mn=r23.mn.bbox(renb1))
pvss0 = dsn.pin(name='VSS', grid=r12, mn=r12.bbox(rvss0))
pvdd0 = dsn.pin(name='VDD', grid=r12, mn=r12.bbox(rvdd0))

# 7. Export to physical database.
print("Export design")
# Magic tcl export.
laygo2.interface.magic.export(lib, filename=ref_dir_MAG_exported +libname+'_'+cellname+'.tcl', cellname=None, libpath=ref_dir_template+'magic_layout', scale=1, reset_library=False, tech_library='sky130A')

# 8. Export to a template database file.
nat_temp = dsn.export_to_template()
temp_dict = laygo2.interface.yaml.export_template(nat_temp, filename=ref_dir_template+libname+'_templates.yaml', mode='append')

"""## Generate D flip-flops"""

# D flip-flop variables
cell_type = 'dff'
nf_list = [2, 4]
r23_name = 'routing_23_cmos'
r34_name = 'routing_34_basic'

# Generation start ##################
# 1. Load templates and grids.
print("Load templates")
templates = tech.load_templates()
tpmos, tnmos = templates[tpmos_name], templates[tnmos_name]
tlib = laygo2.interface.yaml.import_template(filename=ref_dir_template+'logic_generated_templates.yaml')
print(templates[tpmos_name], templates[tnmos_name], sep="\n")

print("Load grids")
grids = tech.load_grids(templates=templates)
pg, r12, r23, r34 = grids[pg_name], grids[r12_name], grids[r23_name], grids[r34_name]
print(grids[pg_name], grids[r12_name], grids[r23_name], grids[r34_name], sep="\n")

for nf in nf_list:
   cellname = cell_type+'_'+str(nf)+'x'
   print('--------------------')
   print('Now Creating '+cellname)

# 2. Create a design hierarchy
   lib = laygo2.object.database.Library(name=libname)
   dsn = laygo2.object.database.Design(name=cellname, libname=libname)
   lib.append(dsn)

# 3. Create istances.
   print("Create instances")
   inv0 = tlib['inv_'+str(nf)+'x'].generate(name='inv0')
   inv1 = tlib['inv_'+str(nf)+'x'].generate(name='inv1')
   inv2 = tlib['inv_'+str(nf)+'x'].generate(name='inv2')
   inv3 = tlib['inv_'+str(nf)+'x'].generate(name='inv3')

   tinv0 = tlib['tinv_'+str(nf)+'x'].generate(name='tinv0')
   tinv1 = tlib['tinv_'+str(nf)+'x'].generate(name='tinv1')

   tinv_small0 = tlib['tinv_small_1x'].generate(name='tinv_small0')
   tinv_small1 = tlib['tinv_small_1x'].generate(name='tinv_small1')

# 4. Place instances.
   dsn.place(grid=pg, inst=inv0, mn=[0,0])
   dsn.place(grid=pg, inst=inv1, mn=pg.mn.bottom_right(inv0))
   dsn.place(grid=pg, inst=tinv0, mn=pg.mn.bottom_right(inv1))
   dsn.place(grid=pg, inst=tinv_small0, mn=pg.mn.bottom_right(tinv0))
   dsn.place(grid=pg, inst=inv2, mn=pg.mn.bottom_right(tinv_small0))
   dsn.place(grid=pg, inst=tinv1, mn=pg.mn.bottom_right(inv2))
   dsn.place(grid=pg, inst=tinv_small1, mn=pg.mn.bottom_right(tinv1))
   dsn.place(grid=pg, inst=inv3, mn=pg.mn.bottom_right(tinv_small1))

   # 5. Create and place wires.
   print("Create wires")

   # 1st M4

   _mn = [r34.mn(inv1.pins['O'])[0], r34.mn(tinv_small1.pins['ENB'])[0]]
   _track = [None, r34.mn(inv1.pins['O'])[0,1]-2]
   mn_list=[]
   mn_list.append(r34.mn(inv1.pins['O'])[0])
   mn_list.append(r34.mn(tinv0.pins['ENB'])[0])
   mn_list.append(r34.mn(tinv1.pins['EN'])[0])
   mn_list.append(r34.mn(tinv_small0.pins['EN'])[0])
   mn_list.append(r34.mn(tinv_small1.pins['ENB'])[0])
   dsn.route_via_track(grid=r34, mn=mn_list, track=_track)

   # 2nd M4
   _track[1] += 1
   mn_list=[]
   mn_list.append(r34.mn(inv0.pins['O'])[0])
   mn_list.append(r34.mn(inv1.pins['I'])[0])
   mn_list.append(r34.mn(tinv0.pins['EN'])[0])
   mn_list.append(r34.mn(tinv1.pins['ENB'])[0])
   mn_list.append(r34.mn(tinv_small0.pins['ENB'])[0])
   mn_list.append(r34.mn(tinv_small1.pins['EN'])[0])
   dsn.route_via_track(grid=r34, mn=mn_list, track=_track)

   # 3rd M4
   _track[1] += 1
   mn_list=[]
   mn_list.append(r34.mn(inv2.pins['I'])[0])
   mn_list.append(r34.mn(tinv0.pins['O'])[0])
   mn_list.append(r34.mn(tinv_small0.pins['O'])[0])
   dsn.route_via_track(grid=r34, mn=mn_list, track=_track)

   mn_list=[]
   mn_list.append(r34.mn(inv3.pins['I'])[0])
   mn_list.append(r34.mn(tinv1.pins['O'])[0])
   mn_list.append(r34.mn(tinv_small1.pins['O'])[0])
   dsn.route_via_track(grid=r34, mn=mn_list, track=_track)

   # 4th M4
   _track[1] += 1
   mn_list=[]
   mn_list.append(r34.mn(inv2.pins['O'])[0])
   mn_list.append(r34.mn(tinv1.pins['I'])[0])
   mn_list.append(r34.mn(tinv_small0.pins['I'])[0])
   dsn.route_via_track(grid=r34, mn=mn_list, track=_track)

   mn_list=[]
   mn_list.append(r34.mn(inv3.pins['O'])[0])
   mn_list.append(r34.mn(tinv_small1.pins['I'])[0])
   dsn.route_via_track(grid=r34, mn=mn_list, track=_track)

   # VSS
   rvss0 = dsn.route(grid=r12, mn=[r12.mn.bottom_left(inv0), r12.mn.bottom_right(inv3)])

   # VDD
   rvdd0 = dsn.route(grid=r12, mn=[r12.mn.top_left(inv0), r12.mn.top_right(inv3)])

   # 6. Create pins.
   pin0 = dsn.pin(name='I', grid=r23, mn=r23.mn.bbox(tinv0.pins['I']))
   pclk0 = dsn.pin(name='CLK', grid=r23, mn=r23.mn.bbox(inv0.pins['I']))
   pout0 = dsn.pin(name='O', grid=r23, mn=r23.mn.bbox(inv3.pins['O']))
   pvss0 = dsn.pin(name='VSS', grid=r12, mn=r12.mn.bbox(rvss0))
   pvdd0 = dsn.pin(name='VDD', grid=r12, mn=r12.mn.bbox(rvdd0))

   # 7. Export to physical database.
   print("Export design")

   # Magic tcl export.
   laygo2.interface.magic.export(lib, filename=ref_dir_MAG_exported +libname+'_'+cellname+'.tcl', cellname=None, libpath=ref_dir_template+'magic_layout', scale=1, reset_library=False, tech_library='sky130A')

   # 8. Export to a template database file.
   nat_temp = dsn.export_to_template()
   laygo2.interface.yaml.export_template(nat_temp, filename=ref_dir_template+libname+'_templates.yaml', mode='append')

!ls *.tcl

"""# Export the final layout in gds format"""

# Commented out IPython magic to ensure Python compatibility.
# %%script bash -c "PDK_ROOT=/usr/local/share/pdk PDKPATH=/usr/local/share/pdk/sky130A magic -dnull -noconsole -rcfile /usr/local/share/pdk/sky130A/libs.tech/magic/sky130A.magicrc"
# addpath /content/laygo2_workspace_sky130/magic_layout/skywater130_microtemplates_dense
# source logic_generated_inv_2x.tcl
# source logic_generated_inv_4x.tcl
# source logic_generated_tinv_2x.tcl
# source logic_generated_tinv_4x.tcl
# source logic_generated_tinv_small_1x.tcl
# source logic_generated_dff_2x.tcl
# source logic_generated_dff_4x.tcl
# load logic_generated_dff_2x
# select top cell
# gds labels no
# gds write dff.gds

"""## Draw the top-level layout"""

import gdstk
import cairosvg
from IPython.display import Image

library = gdstk.read_gds('dff.gds')
#print(library.cells)
top_cells = library.top_level()
top_cells[0].write_svg('dff.svg')
cairosvg.svg2png(url='dff.svg', write_to='dff.png', scale=10.0)
Image('dff.png')

"""## Draw a subcell layout"""

cellname='logic_generated_tinv_2x'
for cell in library.cells:
  print(cell.name)
  if cell.name == cellname:
    cell.write_svg('cell.svg')
cairosvg.svg2png(url='cell.svg', write_to='cell.png', scale=5.0)
Image('cell.png')

