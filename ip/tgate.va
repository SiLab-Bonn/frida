// NOTE: This model was generated by a LLM, based on a prompt as an experiment
// It should not be used/trusted

`include "constants.vams"
`include "disciplines.vams"

module sampling_switch (
    in,         // Input terminal
    out,        // Output terminal
    clk,        // Clock control
    vdd,        // Supply voltage
    vss         // Ground
);

// Port definitions
inout in, out, clk, vdd, vss;
electrical in, out, clk, vdd, vss;

// User Parameters (only dimensions)
parameter real Wn = 1e-6;    // NMOS width (m)
parameter real Ln = 0.1e-6;  // NMOS length (m)
parameter real Wp = 2e-6;    // PMOS width (m)
parameter real Lp = 0.1e-6;  // PMOS length (m)

// Process Parameters (typical 65nm CMOS)
parameter real COX = 10e-3;      // Gate oxide capacitance (F/m²)
parameter real MU_N = 400e-4;    // NMOS mobility (m²/V·s)
parameter real MU_P = 150e-4;    // PMOS mobility (m²/V·s)
parameter real VTHN = 0.3;       // NMOS threshold voltage (V)
parameter real VTHP = -0.3;      // PMOS threshold voltage (V)
parameter real CGDO = 0.5e-9;    // Gate-drain overlap capacitance per width (F/m)
parameter real CINV_FACTOR = 0.5;// Charge injection factor (0-1)
parameter real JLEAK = 1e-3;     // Leakage current density (A/m)
parameter real TOX = 2e-9;       // Oxide thickness (m)

// Internal calculated parameters
real ron_nmos, ron_pmos;
real turnoff_nmos, turnoff_pmos;
real cgd_nmos, cgd_pmos;
real rleak;
real cinj_nmos, cinj_pmos;
real cload;  // Load capacitance will be automatically calculated

// Internal variables
real r_switch;      // Effective switch resistance
real vout_prev;     // Previous output voltage
real vclk_prev;     // Previous clock voltage
real q_injected;    // Charge injected
real q_feedthrough; // Feedthrough charge
real q_pedestal;    // Pedestal charge
real last_clk_fall_time; // Time of last falling edge
integer state;      // Switch state (0=off, 1=on)

analog begin
    // Calculate parameters based on device dimensions
    // On-resistance calculation (simplified square law)
    ron_nmos = 1 / (MU_N * COX * Wn/Ln * (V(clk) - V(in) - VTHN));
    ron_pmos = 1 / (MU_P * COX * Wp/Lp * (V(vdd) - V(clk) - abs(VTHP)));
    
    // Gate-drain capacitance (overlap)
    cgd_nmos = CGDO * Wn;
    cgd_pmos = CGDO * Wp;
    
    // Turn-off time (approximate as RC constant)
    turnoff_nmos = 0.1 * ron_nmos * (COX * Wn * Ln + cgd_nmos);
    turnoff_pmos = 0.1 * ron_pmos * (COX * Wp * Lp + cgd_pmos);
    
    // Leakage resistance (junction leakage)
    rleak = 1 / (JLEAK * (Wn*Ln + Wp*Lp));
    
    // Charge injection capacitance (fraction of gate capacitance)
    cinj_nmos = CINV_FACTOR * COX * Wn * Ln;
    cinj_pmos = CINV_FACTOR * COX * Wp * Lp;
    
    // Automatic load capacitance estimation (sum of drain caps)
    cload = 0.5 * COX * (Wn*Ln + Wp*Lp) + cgd_nmos + cgd_pmos;
    
    // Get clock voltage
    real vclk = V(clk);
    
    // Detect clock edges
    integer clk_rising = (vclk > (V(vdd)+V(vss))/2) && (vclk_prev <= (V(vdd)+V(vss))/2);
    integer clk_falling = (vclk <= (V(vdd)+V(vss))/2) && (vclk_prev > (V(vdd)+V(vss))/2);
    
    // Switch state logic
    if (vclk > (V(vdd)+V(vss))/2) begin
        // Switch is on
        state = 1;
        r_switch = (ron_nmos * ron_pmos) / (ron_nmos + ron_pmos); // Parallel combination
    end else begin
        // Switch is turning off or off
        state = 0;
        
        // Model unequal turn-off times
        real time_since_fall = $abstime - last_clk_fall_time;
        real nmos_off = (time_since_fall >= turnoff_nmos) ? 1 : 0;
        real pmos_off = (time_since_fall >= turnoff_pmos) ? 1 : 0;
        
        if (nmos_off && pmos_off) begin
            r_switch = rleak; // Full off state with leakage
        end else begin
            // Partial turn-off state
            r_switch = 1.0 / (1e-18 + nmos_off/ron_nmos + pmos_off/ron_pmos);
        end
    end
    
    // Track clock edges for timing
    if (clk_falling) begin
        last_clk_fall_time = $abstime;
        
        // Calculate charge injection (both devices contribute)
        q_injected = cinj_nmos * (vclk_prev - V(in) - VTHN) + 
                    cinj_pmos * (V(vdd) - vclk_prev - abs(VTHP));
        
        // Calculate pedestal step (clock feedthrough)
        q_pedestal = cgd_nmos * (vclk_prev - V(out)) + cgd_pmos * (vclk_prev - V(out));
    end
    
    // Model feedthrough during hold mode
    if (state == 0) begin
        q_feedthrough = cgd_nmos * (vclk - vclk_prev) + cgd_pmos * (vclk - vclk_prev);
    end else begin
        q_feedthrough = 0;
    end
    
    // Calculate output voltage
    real i_switch = (V(in) - V(out)) / r_switch;
    real i_leak = V(out) / rleak;
    real i_cap = ddt(V(out) * cload);
    
    // Current balance equation
    I(out) <+ i_switch - i_leak - i_cap;
    
    // Add noise (kT/C noise during sampling)
    if (state == 1) begin
        I(out) <+ white_noise(4 * `P_K * $temperature / (ron_nmos + ron_pmos), "thermal");
        I(out) <+ white_noise(`P_K * $temperature / cload, "ktc"); // kT/C noise
    end else begin
        I(out) <+ white_noise(4 * `P_K * $temperature / rleak, "leakage");
    end
    
    // Add charge injection effects at falling edge
    if (clk_falling) begin
        I(out) <+ transition(q_injected / 1e-12, 0, 1e-12);
        I(out) <+ transition(q_pedestal / 1e-12, 0, 1e-12);
    end
    
    // Add feedthrough during hold
    if (state == 0 && (vclk != vclk_prev)) begin
        I(out) <+ transition(q_feedthrough / 1e-12, 0, 1e-12);
    end
    
    // Update previous values
    vout_prev = V(out);
    vclk_prev = vclk;
end

endmodule